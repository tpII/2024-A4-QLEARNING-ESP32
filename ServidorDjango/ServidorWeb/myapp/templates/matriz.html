<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matriz</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(120deg, #1a1a2e, #16213e); /* Fondo degradado azul oscuro */
            color: white;
            text-align: center;
        }

        header {
            background-color: #6683a7;
            padding: 20px;
        }

        header img {
            width: 200px; /* Ajusta el tamaño del logo */
        }

        h1 {
            margin: 20px 0;
            color: #ffffff;
        }

        table {
            border-collapse: collapse;
            margin: 20px auto;
            background: #e0e0e0; /* Fondo claro para contraste */
            color: #000;
        }

        td, th {
            border: 1px solid #000;
            padding: 10px;
            text-align: center;
        }

        .buttons {
            text-align: center;
            margin: 20px;
        }

        button {
            padding: 15px 30px;
            font-size: 18px;
            margin: 10px;
            border: none;
            border-radius: 50px; /* Botones redondeados */
            color: white;
            background: #0077b6; /* Azul vibrante */
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background: #023e8a; /* Azul más oscuro al pasar el cursor */
        }

        button:active {
            background: #005f73; /* Azul intenso al hacer clic */
        }

        p {
            margin: 20px auto;
            font-size: 18px;
        }
        #direccion-button {
            padding: 15px 30px;
            font-size: 18px;
            color: white;
            background: #ff5722; /* Naranja brillante */
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin: 10px auto; /* Centra el botón */
            display: inline-block;
        }

        #direccion-button:hover {
            background: #e64a19; /* Naranja más oscuro */
        }

        #direccion-button:active {
            background: #d84315; /* Naranja intenso */
        }
        #direccion-texto {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <header>
    {% load static %}
    <img src="{% static '/crawler.png' %}" alt="CrawlerBot Logo">

    </header>


    <main>
        <h1>
            <div>
                <span id="direccion-texto">Adelante</span> <!-- Texto dinámico -->
            </div>
            <div>
                <span id="direccion-flecha">↑</span> <!-- Flecha -->
            </div>
        </h1>
        <h1>Estado: <span id="estado-crawler">{{ estado_crawler }}</span></h1>
        <h1>Matriz Recibida</h1>
        {% if matriz %}
            <table>
         <!-- La tabla se llenará dinámicamente -->

                {% for fila in matriz %}
                    <tr>
                        {% for valor in fila %}
                            <td>{{ valor }}</td>
                        {% endfor %}
                    </tr>
                {% endfor %}
            </table>
        {% else %}
            <p>No se ha recibido ninguna matriz aún.</p>
        {% endif %}
        <div class="buttons">
            <div>
                <button id="start-button" onclick="handleStart()">Start</button>
                <button id="stop-button" onclick="handleStop()">Stop</button>
            </div>
            <div>
                <button id="direccion-button" onclick="toggleDireccion()">Dirección</button>
            </div>
        </div>
    </main>

    <script>
    async function handleStart() {
        try {
            const response = await fetch('/start/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}', // Usamos el token CSRF de Django
                    'Content-Type': 'application/json'
                }
            });
            if (response.ok) {
                const data = await response.json();
                console.log("Start activated:", data);
            } else {
                console.error("Error al activar Start:", response.statusText);
            }
        } catch (error) {
            console.error("Error de conexión:", error);
        }
    }

    async function handleStop() {
        try {
            const response = await fetch('/stop/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}',
                    'Content-Type': 'application/json'
                }
            });
            if (response.ok) {
                const data = await response.json();
                console.log("Stop activated:", data);
            } else {
                console.error("Error al activar Stop:", response.statusText);
            }
        } catch (error) {
            console.error("Error de conexión:", error);
        }
    }

    async function toggleDireccion() {
        try {
            // Obtén el estado actual
            const responseGet = await fetch('/api/get_direccion_crawler/', { cache: "no-store" });
            if (responseGet.ok) {
                const data = await responseGet.json();
                const currentDireccion = data.direccionCrawler;
                console.log(`Dirección actual: ${currentDireccion}`);

                // Alterna el valor de la dirección (0 a 1 o 1 a 0)
                const newDireccion = currentDireccion === 0 ? 1 : 0;

                // Envía el nuevo valor al servidor
                const responseSet = await fetch('/api/set_direccion_crawler/', {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': '{{ csrf_token }}',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ direccionCrawler: newDireccion }),
                    cache: "no-store"
                });

                if (responseSet.ok) {
                    console.log(`Dirección alternada: ${newDireccion}`);
                    // Actualiza la flecha solo si el cambio fue exitoso
                    actualizarFlecha(newDireccion);
                } else {
                    console.error("Error al alternar dirección:", responseSet.statusText);
                }
            } else {
                console.error("Error al obtener dirección actual:", responseGet.statusText);
            }
        } catch (error) {
            console.error("Error de conexión:", error);
        }
    }

    // Función para actualizar la flecha según la dirección
    function actualizarFlecha(direccion) {
        const flecha = document.getElementById('direccion-flecha');
        const texto = document.getElementById('direccion-texto');
        
        if (direccion === 0) {
            flecha.textContent = '↑';
            texto.textContent = 'Adelante';
        } else {
            flecha.textContent = '↓';
            texto.textContent = 'Hacia Atrás';
        }
    }

    // Inicializa la flecha al cargar la página
    async function inicializarFlecha() {
        try {
            const response = await fetch('/api/get_direccion_crawler/', { cache: "no-store" });
            if (response.ok) {
                const data = await response.json();
                actualizarFlecha(data.direccionCrawler);
            } else {
                console.error("Error al obtener dirección inicial:", response.statusText);
            }
        } catch (error) {
            console.error("Error de conexión:", error);
        }
    }

    // Llama a la inicialización al cargar
    inicializarFlecha();

    
        // Función para actualizar el estado
        async function actualizarEstado() {
            try {
                const response = await fetch('/api/get_estado_crawler/');
                if (response.ok) {
                    console.log("entre");
                    const data = await response.json();
                    document.getElementById('estado-crawler').textContent = data.estado_crawler;
                } else {
                    console.error("Error al obtener el estado:", response.statusText);
                }
            } catch (error) {
                console.error("Error de conexión:", error);
            }
        }

        // Llama a la función cada segundo
        setInterval(actualizarEstado, 1000);

        
        // Función para actualizar la matriz
        async function actualizarMatriz() {
        try {
            const response = await fetch('/api/get_matriz/');
            if (response.ok) {
                const data = await response.json();
                const matriz = data.matriz;

                // Actualizar la tabla
                const tabla = document.querySelector('table');
                if (tabla) {
                    // Eliminar filas existentes
                    while (tabla.rows.length > 0) {
                        tabla.deleteRow(0);
                    }

                    // Crear nuevas filas
                    matriz.forEach(fila => {
                        const tr = document.createElement('tr');
                        fila.forEach(valor => {
                            const td = document.createElement('td');
                            td.textContent = valor;

                            // Aplicar color basado en el valor
                            const color = calcularColor(valor);
                            td.style.backgroundColor = color;

                            tr.appendChild(td);
                        });
                        tabla.appendChild(tr);
                    });
                }
            } else {
                console.error("Error al obtener la matriz:", response.statusText);
            }
        } catch (error) {
            console.error("Error de conexión:", error);
        }
    }
    setInterval(actualizarMatriz, 5000);
    // Función para calcular el color basado en el valor
    // Función para calcular el color basado en el valor
    function calcularColor(valor) {
        if (valor > 0) {
            // Valores positivos: verdes
            const opacidad = Math.abs(valor); // Mayor opacidad cuanto más cerca esté de 1
            return `rgba(0, 255, 0, ${opacidad})`;
        } else if (valor < 0) {
            // Valores negativos: rojos
            const opacidad = Math.abs(valor); // Mayor opacidad cuanto más cerca esté de -1
            return `rgba(255, 0, 0, ${opacidad})`;
        } else {
            // Valor 0: sin color (transparente o blanco)
            return `rgba(255, 255, 255, 1)`;
        }
    }

        // Llama a la función cada 5 segundos


    </script>
</body>
</html>
